[ { "title": "The False Sense of Security: Running Containers as root", "url": "/posts/containers-running-as-root/", "categories": "Containers", "tags": "Containers, Security", "date": "2023-03-26 14:30:00 +0500", "snippet": "Containers have revolutionized modern software development, enabling us to develop, build, package, and deploy software applications faster and more efficiently than ever before. The benefits of containerization are many, from easier deployment and scaling to improved resource utilization and portability. However, despite the advantages that containers offer, they are not immune to security risks. In this post, let’s discuss how root inside the container and on the host essentially mean one and the same thing.Insecure By DefaultIn her book Container Security, Liz Rice described containers running as root as “the most insecure-by-default behavior in the container world”, and despite this behavior being insecure, at the time of this writing, most if not all containers still run as root by default.For instance, if we spin up an Ubuntu container using Docker and check the user ID, we can see that it’s running as root:$ docker run -it ubuntu /bin/bashroot@3de6e3805519:/# iduid=0(root) gid=0(root) groups=0(root)One might mistakenly assume like I myself had once believed, that root inside a container is completely isolated from the root on the host. However, that is not the case.To confirm that root in the Ubuntu container is the same as the root on the host, let’s run the sleep command inside the container:root@3de6e3805519:/# sleep infinityNow, let’s open another terminal on the same host, and use the ps command to see that this process is running under root’s user ID:$ ps -fC sleepUID PID PPID C STIME TTY TIME CMDroot 4434 4152 0 19:38 pts/0 00:00:00 sleep infinityFrom the perspective of the host, the sleep process is owned by the root user, as seen above. This indicates that root inside the container is essentially the same as root on the host.This leads us to the question: how can attackers take advantage of this? So let’s now explore how this practice could be abused by an attacker.Leveraging Containers for Privilege EscalationAssuming we already have initial access to the machine as a normal non-root user on the host, let’s demonstrate how an attacker can use containers to escalate their privileges.To begin, we’ll run an Ubuntu container and bind-mount the host’s /tmp volume inside the container using the following command:$ docker run -v /tmp:/tmp -it ubuntu /bin/bashroot@2ea086531742:/#With the container up and running, let’s open another terminal on the host as non-root user and copy the user’s /bin/bash file to the /tmp directory using the following command:$ cp /bin/bash /tmpNext, in the Ubuntu container, let’s see who owns the /tmp/bash file:root@2ea086531742:/# ls -l /tmp/bash -rwxr-xr-x 1 1000 1001 1234376 Mar 25 17:21 /tmp/bashAs we can see, the file is currently owned by the non-root user with UID 1000.Now, we’ll use the chown command to change the ownership of the file to the root user:root@2ea086531742:/# chown root:root /tmp/bashroot@2ea086531742:/# ls -l /tmp/bash-rwxr-xr-x 1 root root 1234376 Mar 25 17:21 /tmp/bashThe file is now owned by root, so we’ll set the setuid bit on the file using the chmod command:root@2ea086531742:/# chmod +s /tmp/bashroot@2ea086531742:/# ls -l /tmp/bash-rwsr-sr-x 1 root root 1234376 Mar 25 17:21 /tmp/bashNow that the setuid bit is set, we can go back to the terminal of the non-root user and execute the /tmp/bash file with the -p option to launch bash in privileged mode and maintain the privileges owned by the file’s owner:$ /tmp/bash -pbash-5.1# whoamirootSo now, even though we ran the /tmp/bash file as a regular non-root user, we have become root on the host.If you want to see this in action, I suggest giving HackTheBox’s now-retired GoodGames machine a try. A good friend of mine, Abdullah Rizwan has a nice writeup on the machine.Furthermore, there are numerous other techniques that attackers can use to escape their privileges, such as this in the blog post from Ferry Boender, or the one by Marc Campbell.RemediationIf you’re using Docker as your container runtime, the fix is as simple as adding the following two lines to your Dockerfile:RUN groupadd --gid 65532 nonroot \\ &amp;amp;&amp;amp; useradd --uid 65532 --gid 65532 -m nonrootUSER nonrootAlternatively, if you’re working with Kubernetes, you can leverage the securityContext setting or PodSecurityPolicy. However, since the latter is deprecated, here’s an example of how you can use the former to prevent privilege escalation:securityContext: allowPrivilegeEscalation: false capabilities: drop: - ALL runAsNonRoot: trueConclusionTo sum up, we’ve learned how the ephemeral nature of containers can give us a false sense of security, and that root inside a container is equivalent to root on the host. This means that a successful container escape can lead to a complete compromise of the host. To prevent this, it’s crucial to follow the principle of least privilege and adopt security best practices. Without these measures, we’d just be a single misconfiguration away from allowing an attacker to gain full control." }, { "title": "National Cyber Security Hackathon 2022 — Cryptography Write Up", "url": "/posts/National-Hackathon-2022/", "categories": "Hackathon, Crypto", "tags": "CTF, crypto, Hackathon", "date": "2022-12-25 22:40:00 +0500", "snippet": "There’s a saying that gets thrown around a lot in the cybersecurity community, “Never roll your own crypto”, which refers to the idea that it is generally not recommended to create your own cryptographic algorithms or protocols, and instead to use established and well-vetted implementations.In this writeup, let’s explore the solutions to the cryptography challenges from the National Cyber Security Hackathon 2022 and consider the reasons behind this saying and some common pitfalls to avoid when doing cryptography. Heads up, the code coming up might not be the prettiest. I’m a hacker first, then a software engineer, so when I’m trying to hack together a solution, aesthetics and best practices often take the backseat.So without further ado, let’s get started.Extreme Ratio — Karachi QualifierThis challenge was classified as hard and was worth 200 points. The following source code was provided.Source Code#!/usr/bin/env python3import gzipimport osfrom Crypto.Cipher import AESfrom Crypto.Util import CounterENCRYPT_KEY = os.urandom(16)FLAG = b&#39;flag{*************************}&#39;def encrypt_ctr(data): ctr = Counter.new(64, prefix=os.urandom(8)) cipher = AES.new(ENCRYPT_KEY, AES.MODE_CTR, counter=ctr) ctxt = cipher.encrypt(data) return ctxtdef encrypt_ecb(data): cipher = AES.new(ENCRYPT_KEY, AES.MODE_ECB) ctxt = cipher.encrypt(data) return ctxtprint(&quot;(Compress|Encrypt)ion Service\\n&quot;)print(&quot;Available Options: &quot;)print(&quot;[0] Encryption Only (AES CTR)&quot;)print(&quot;[1] Encryption Only (AES ECB)&quot;)print(&quot;[2] Compression + Encryption: (Gzip + AES CTR)&quot;)print(&quot;[3] Compression + Encryption: (Gzip + AES ECB)&quot;)try: option = int(input(&quot;&amp;gt;&amp;gt; &quot;)) if option &amp;lt; 0 or option &amp;gt; 3: print(&quot;Wrong Option&quot;) exit(1)except: print(&quot;Error&quot;) exit(-1)while True: ptxt_hex = input(&quot;Data (hex encoded): &quot;) if len(ptxt_hex) &amp;lt; 32: continue ptxt = FLAG + bytes.fromhex(ptxt_hex) if option == 0: ctxt = encrypt_ctr(ptxt) elif option == 1: ctxt = encrypt_ecb(ptxt) elif option == 2: ptxt = gzip.compress(ptxt) ctxt = encrypt_ctr(ptxt) elif option == 3: ptxt = gzip.compress(ptxt) ctxt = encrypt_ecb(ptxt) out = ctxt + bytes([len(ctxt)]) print(out.hex())Initial AnalysisThe code is a simple command-line utility that provides four options: Encryption with AES in CTR mode Encryption with AES in ECB mode Compression with gzip followed by encryption with AES in CTR mode Compression with gzip followed by encryption with AES in ECB modeThe flag is declared at the start of the program along with the randomly generated AES key and IV/Counter. The user is prompted to select an option, and then to input data, which is concatenated with the flag and then encrypted according to the selected option. The result is then printed on the command line.Initially, the code does not seem to be vulnerable, as it appears to use secure cryptographic practices such as generating random keys and IVs/Counters. However, upon a closer look, we find that the third and fourth options are modeled on the CRIME attack. I was familiar with this attack because I had previously come across and solved a similar problem and had read about the concept. Here’s what Wikipedia has to say about the attack: CRIME (Compression Ratio Info-leak Made Easy) is a security vulnerability in HTTPS and SPDY protocols that utilize compression, which can leak the content of secret web cookies.[1] When used to recover the content of secret authentication cookies, it allows an attacker to perform session hijacking on an authenticated web session, allowing the launching of further attacks. CRIME was assigned CVE-2012-4929.[2]Proof of ConceptHere’s how the attack works:Say we compress three similar strings, Hello World!, Hello Hello World!, Hello There World!&amp;gt;&amp;gt;&amp;gt; import gzip&amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;Hello World!&quot;))32&amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;Hello Hello World!&quot;))34&amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;Hello There World!&quot;))38Notice the changes in lengths of compressed input strings? Well, that’s how compression works. It identifies repeating patterns in the input and replaces them with a smaller representation.Explain Like I’m FiveThe first input string is Hello World!, which when compressed, is 32 bytes long. The second input string is Hello Hello World!, which has a slightly longer compressed representation (34 bytes) because it has more repeated characters. The third input string is Hello There World!, which has an even longer compressed representation (38 bytes) because it has fewer repeated characters and more unique characters. In short, the more repetition there is, the shorter the compressed representation will be. And that’s all we need to crack this challenge.The AttackWe know that the flag value starts with flag{, and is likely made up of ASCII letters, digits, and special characters _{}. It’s also very likely that the flag will not consist of the ; character. With that knowledge, we can begin the process of recovering the flag.Here’s a step by step breakdown of the process: Create a payload by appending an invalid_char to the flag and multiplying the resulting string by 5 (this will ensure that the len(ptxt_hex) &amp;gt; 32 condition is satisfied). Send the payload to the server and store the length of the response in a variable called response_length. (Refer to step 4 and you’ll realize why we’re only interested in length) Repeat the process, but this time append each character that is likely to be in the flag to the flag instead of the invalid_char. Compare the length of the current response to the initial response_length. If the length of the current response is smaller than the initial response, it means that the current character is likely to be part of the flag. This can be best explained by the following example: &amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;flag{test_flag}&quot; + b&quot;flag{;&quot;)) # invalid char 37 &amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;flag{test_flag}&quot; + b&quot;flag{t&quot;)) # correct char 36 &amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;flag{test_flag}&quot; + b&quot;flag{te&quot;)) # correct char 36 &amp;gt;&amp;gt;&amp;gt; len(gzip.compress(b&quot;flag{test_flag}&quot; + b&quot;flag{test_flag}&quot;)) # correct char 36 Add the current character to the flag value. Repeat this process until the flag is fully recovered.Attack Codefrom pwn import *from string import ascii_letters, digitsflag = &quot;flag{&quot; # known partial flagchars = ascii_letters + digits + &quot;_&quot; # flag charsetinvalid_char = &#39;;&#39; # char that we know will not exist in the flagio = remote(&#39;13.37.13.37&#39;, 1337) # make connection with the serverio.recvuntil(b&quot;&amp;gt;&amp;gt;&quot;)io.sendline(b&quot;2&quot;)io.recvuntil(b&quot;Data (hex encoded): &quot;)payload = (flag + invalid_char) * 5 # craft payload with the invalid char willinglyio.sendline(payload.encode().hex().encode()) # send payloadresponse = io.recvline().decode() # receive responseresponse_length = len(response) # length of received reponseknown_flag = &quot;flag{******************************}&quot; # useful to calculate lengthwhile len(flag) != len(known_flag) - 1: # loop till found flag &amp;lt; actual flag for char in chars: # try all chars io.recvuntil(b&quot;Data (hex encoded): &quot;) payload = ((flag + char) * 5).encode().hex().encode() # append char with known flag io.sendline(payload) response = io.recvline().decode()# If length of current response is less than the response we received for invalid char,# it means we have found the correct char for the current position.# Append the char to the flag and continue. if len(response) &amp;lt; response_length: flag += char print(flag) breakflag += &quot;}&quot;print(flag)┌──(w㉿kali)-[~]└─$ python3 solve.pyflag{cflag{coflag{comflag{compflag{comprflag{compreflag{compresflag{compressflag{compressiflag{compressioflag{compressionflag{compression_flag{compression_rflag{compression_raflag{compression_ratflag{compression_ratiflag{compression_ratioflag{compression_ratio_flag{compression_ratio_sflag{compression_ratio_siflag{compression_ratio_sidflag{compression_ratio_sideflag{compression_ratio_side_flag{compression_ratio_side_cflag{compression_ratio_side_chflag{compression_ratio_side_chaflag{compression_ratio_side_chanflag{compression_ratio_side_channflag{compression_ratio_side_channeflag{compression_ratio_side_channelflag{compression_ratio_side_channel}It took me around 10 minutes to solve this challenge, and approximately two hours to write the explanation for the solution.Weird — Lahore QualifierWe’re provided with the following parameters for this challenge.p = 176023127217849634927507644091332103662520798054278045327249238656498565387166410134529055214072955585770692068345570429086751483097092606584061804212765484464710219858985411381151536676964148178819264599826409752010695119522361661128265187444633270601478731133478455869738783525606488878825620612673405443451q = 112223742839001528812998118414186973172817700984809834685105385564920931672517928021207242740576468083925973443165114290353820217347317026045854850099010720339559464915862999940561296479870088962751450854529450600985614397788176734730474800832462529288309338861856248732919840555336781231835349093136651776199dp = 30385087538855105185173631572543831910674493438359546631957370965394172444160714756294203320157155777516716569112588031576849314924796304802920730636229236548768238849909313008742374774478823911081516143430774367261518805277000586852931743778506123941097942991716525694686408217996359250833964223155034398849dq = 16565834851621714934943194340380561354378406645660464449478884583192424151732554179201902353804271636654563551379619523372168111644035752758829399035221380255914879788552481418444975048102550117169468808280550250275236324494363826390413993168761753803593832990575552156785084689157314624226120721693168527045ct = 12471250728278476973667997300089729054215534203191298445075721390063696581388107032026935036071214619926891164048897398168910187436274670469379883863773864404832345129175958512553655002601862046540235957444868738298616361692115344364105067726967540803482175683177928601460820055610057091618766365214386842148469007862547736382438539960143699747392070571106949826103889774269543672861821736945264589704316771379195593723822149690773183639123458879061206847327965981924555643367839051015699745254023361484614560953387636228877078592886198124833581947075581814292380432723836026412556502710472578640877967731483702882569Initial AnalysisFrom the Wikipedia page of RSA cryptosystem, the presence of p, q, dp, dq, and ct is a strong indication that a variant of RSA with Chinese Remainder Theorem is used.Normally, RSA can take a while to decrypt a ciphertext because it involves raising the ciphertext to the power of the private key modulo the modulus, which can be a pain with big numbers. But with CRT, we can make the whole process a lot faster by taking two modular exponentiations with smaller exponents and moduli. To use RSA with CRT, we have to generate our RSA key a certain way and have a few extra values on hand, like $dp$, $dq$, and $q_{inv}$. Then we can just plug those values in along with the ciphertext and boom, decryption happens a lot quicker.SolutionSince we have all the necessary parameters, we can just follow the decryption process as described on the Wikipedia page.\\[q_{inv} = q^{-1} \\mod p\\]\\[m_1 = c^{d_P} \\mod p\\]\\[m_2 = c^{d_Q} \\mod q\\]\\[h = q_{inv}(m_1 - m_2) \\pmod p\\]\\[m = m_2 + hq \\pmod{pq}\\]I have implemented the following solution in Pythonfrom Crypto.Util.number import *p = 176023127217849634927507644091332103662520798054278045327249238656498565387166410134529055214072955585770692068345570429086751483097092606584061804212765484464710219858985411381151536676964148178819264599826409752010695119522361661128265187444633270601478731133478455869738783525606488878825620612673405443451q = 112223742839001528812998118414186973172817700984809834685105385564920931672517928021207242740576468083925973443165114290353820217347317026045854850099010720339559464915862999940561296479870088962751450854529450600985614397788176734730474800832462529288309338861856248732919840555336781231835349093136651776199dp = 30385087538855105185173631572543831910674493438359546631957370965394172444160714756294203320157155777516716569112588031576849314924796304802920730636229236548768238849909313008742374774478823911081516143430774367261518805277000586852931743778506123941097942991716525694686408217996359250833964223155034398849dq = 16565834851621714934943194340380561354378406645660464449478884583192424151732554179201902353804271636654563551379619523372168111644035752758829399035221380255914879788552481418444975048102550117169468808280550250275236324494363826390413993168761753803593832990575552156785084689157314624226120721693168527045ct = 12471250728278476973667997300089729054215534203191298445075721390063696581388107032026935036071214619926891164048897398168910187436274670469379883863773864404832345129175958512553655002601862046540235957444868738298616361692115344364105067726967540803482175683177928601460820055610057091618766365214386842148469007862547736382438539960143699747392070571106949826103889774269543672861821736945264589704316771379195593723822149690773183639123458879061206847327965981924555643367839051015699745254023361484614560953387636228877078592886198124833581947075581814292380432723836026412556502710472578640877967731483702882569q_inv = inverse(q, p)m1 = pow(ct, dp, p)m2 = pow(ct, dq, q)h = q_inv*(m1 - m2) % pm = m2 + h*q % (p * q)print(long_to_bytes(m))When we run the code, we get the flag: FLAG{Ch!n3z_R3m@!nd3r_the0r3m_!$_U$3d_W!th_RSA_!_}RSA Tricks — Lahore QualifierFor this challenge, the source code and its output were both provided.Source Codefrom Crypto.Util.number import getPrime, bytes_to_long, inverseflag = b&quot;Flag{XXXXXXXXXXXXXXXXXX}&quot;p = getPrime(1024)q = getPrime(1024)N = p*qphi = (p-1)*(q-1)e = 65537d = inverse(e, phi)my_key = (N, d)keys = [(N, getPrime(16)) for i in range(10)]cipher = bytes_to_long(flag)for key in keys: cipher = pow(cipher, key[1], key[0])print(&quot;- My private key&quot;,my_key)print(&quot;- keys&quot;,keys)print(&quot;- Encrypted DATA&quot;,cipher)Output- My private key (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 6687607858232036068102764628763869770365480322599654007055390473672368166120078970889731780497544904312162417086944174061956166089097159465136283083934145573266810680333793401383561399492464805933196541665940377169806871229249258898514253795798667416326565964700803909765395310435346968714809745195915667635297064990795636997497174353498801451968512519467684250340907454722122526744868301815309377979214139209924022710213407189093358499791347140504060386679433394906044887470451126139251537410999047504158074154840567036307276609901744175974470733352724690467371739007984796402241006187231818157691483372021327246081)- keys [(18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 47041), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 43997), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 64327), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 61091), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 41333), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 43753), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 49297), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 60859), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 62549), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 61603)]- Encrypted DATA 17645273145351275595525807073989050948965947318364568960587912808565753550868679400761129493639312107881718704399079296084071662498685695737565304759095440251260751277410423164152439238058543479248616726569219754716569949310088729774754396896206740072798713368055282255138359044165511083329692314841881710654928579684619972781423759855118466981710663456827148741309715289690086375657132843333725276700434878544086599889531450088127607426279698041000280210449286322740624514005407432190062616631972904127404246574154910765957984452167524351965862221718745754696108925882968967217857798769220085678518029334502303515802Initial AnalysisInitially, the program calculates all the stuff it needs to use RSA, like p, q, N, phi, e, and d. Then it calculates 10 public keys that all use the same N, but each has a different, randomly chosen value for e. After that, it loops through all 10 keys and uses each one to encrypt the flag sequentially, and then it prints out the private key, the 10 public keys, and the final encrypted flag.SolutionThe only missing piece to solve this challenge is the value for phi, which we will need to calculate the private keys for the 10 public keys. There’s no direct way to calculate phi with the given values. However, we can use d to calculate the values of prime factors p and q, and then use that to calculate phi.This stack exchange post discusses how to recover prime factors p and q using private exponent d. From there, we can proceed with the following calculation to calculate phi\\[\\phi(N) = (p - 1) \\times (q - 1)\\]After that, we can calculate the private exponents for the 10 public keys using\\[d = e^{-1} \\mod \\phi(N)\\]The following implementation in python can be used for recovering p, q from d (I reused the code from here) and then calculating phi. It can then be used to sequentially decrypt the ciphertext by looping through the keys in reversed order.from Crypto.Util.number import *from sympy import nextprimeimport mathkeys = [(18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 47041), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 43997), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 64327), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 61091), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 41333), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 43753), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 49297), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 60859), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 62549), (18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 61603)]my_key = 18909558900895372672156824811256265991045063590569226191232596663778841681897127254948673384177564949258183981733845039930038021269357172312824082512373461836016350485677617488414637304277231253190262393267785594036484291990305836587795696393789682736379072984234903176904595412028705422757031938515174955122139225813788578454554534920388492258873319280552513284340011592837218450406177853876475453942250479834504622472801073857140934073199654193170101024653069855430546354617875613752042483103556896551326630710625617338594124873967949453649106318872176809724548259100966707725474321152035379845934513208799372680981, 6687607858232036068102764628763869770365480322599654007055390473672368166120078970889731780497544904312162417086944174061956166089097159465136283083934145573266810680333793401383561399492464805933196541665940377169806871229249258898514253795798667416326565964700803909765395310435346968714809745195915667635297064990795636997497174353498801451968512519467684250340907454722122526744868301815309377979214139209924022710213407189093358499791347140504060386679433394906044887470451126139251537410999047504158074154840567036307276609901744175974470733352724690467371739007984796402241006187231818157691483372021327246081c = 17645273145351275595525807073989050948965947318364568960587912808565753550868679400761129493639312107881718704399079296084071662498685695737565304759095440251260751277410423164152439238058543479248616726569219754716569949310088729774754396896206740072798713368055282255138359044165511083329692314841881710654928579684619972781423759855118466981710663456827148741309715289690086375657132843333725276700434878544086599889531450088127607426279698041000280210449286322740624514005407432190062616631972904127404246574154910765957984452167524351965862221718745754696108925882968967217857798769220085678518029334502303515802d = my_key[1]n = my_key[0]e = 65537def find_prime_factors(n, e, d): k = e * d - 1 s = 0 t = k while t % 2 == 0: t = t // 2 s += 1 i = s a = 2 while True: b = pow(a, t, n) if b == 1: a = nextprime(a) continue while i != 1: c = pow(b, 2, n) if c == 1: break else: b = c i -= 1 if b == n - 1: a = nextprime(a) continue p = math.gcd(b-1, n) q = n // p return p, qp, q = find_prime_factors(n, 65537, d)assert p * q == nphi = (p - 1) * (q - 1)for key in keys[::-1]: e2 = key[1] d = inverse(e2, phi) c = pow(c, d, n)print(long_to_bytes(c))When we run the code, it prints out the flag: Flag{N0_M1stak3s_W1th_RSA}Simple RSA — Peshawar QualifierThe following values were provided with the challenge.n=16147111734460800396004592670421468929337203190257626881606012921435838643682486839638969919126011524499609044486548371078702382995209772340989167246102495015107720926778322642181742667106589581285868164349155811160988904172418976556526686941401355790760512930187413129387612432578824982589943249726538251843134494371205312446417743116926422296053343015812167511415786346049084785782293317209821769860285282759086233935620489199236381431918736093892708407699240019615286528179061459943754101031540022336347845482100465143834304730276518967143705254840069157949656506425821092281518997158195127056924848015561721144141e=5ct=111558645679006394985384019922106344256390245431545304101942130922177467904633500612867289903603121371437773246170390092045034734209187474652129636135263800118498886868963176721482556951317449397588032806400411456314451471867958481146150654899999731639797463584634515914586016365684332024632542448233024172820905812188634527134114383199826766449312686149601042672866478590545407942592434984704530370917178774467061817245773716440844189325157951539629919700395694364926837338497933420304953156481808563506013769102906246159631644750831210893Initial AnalysisIn this challenge, we are given three values: n, e, and ct. These variables are commonly used in the RSA, with n being the modulus (product of two primes p and q), e being the public exponent, and ct being the result of the encryption.SolutionIn RSA, ct is calculated using the equation\\[ct = pt^{e} \\mod n\\]It is not practical to find the flag by factoring n, as it is too large. However, we can use the small value of ct to our advantage. A small value of ct indicates that the plaintext pt is also small, meaning that the value of $pt^e$ is unlikely to exceed the modulus n.Mathematically, this would mean that\\[ct = pt^e\\]We have the values of e and ct. Using the above equation, we can find the value of pt by taking the $e_{th}$ root of ct.\\[pt = \\sqrt[e]{ct}\\]The following code in Python can be used to do the heavy lifting and find the flag.from Crypto.Util.number import *from gmpy2 import irootn=16147111734460800396004592670421468929337203190257626881606012921435838643682486839638969919126011524499609044486548371078702382995209772340989167246102495015107720926778322642181742667106589581285868164349155811160988904172418976556526686941401355790760512930187413129387612432578824982589943249726538251843134494371205312446417743116926422296053343015812167511415786346049084785782293317209821769860285282759086233935620489199236381431918736093892708407699240019615286528179061459943754101031540022336347845482100465143834304730276518967143705254840069157949656506425821092281518997158195127056924848015561721144141e=5ct=111558645679006394985384019922106344256390245431545304101942130922177467904633500612867289903603121371437773246170390092045034734209187474652129636135263800118498886868963176721482556951317449397588032806400411456314451471867958481146150654899999731639797463584634515914586016365684332024632542448233024172820905812188634527134114383199826766449312686149601042672866478590545407942592434984704530370917178774467061817245773716440844189325157951539629919700395694364926837338497933420304953156481808563506013769102906246159631644750831210893pt = iroot(ct, e)[0]print(long_to_bytes(pt))When we run the code, we get the flag: FLAG{1_7h1nk_7h3_p4dd1n9_w4sn&#39;7_l00n9_en0ugh}Weird RSA — Islamabad QualifierFor this challenge, we are given the following values and a hint that suggests using the Tonelli-Shanks algorithm.N = 139799611644152653629701760688199671817845996420960212837951252403071310661876297820375820252422246921626014752203411034874959269400969108775865662803612855844497453022528516710849383838452964627284555992534657432806346951988469594342508507343895146379695281224818693776589341387464488798959628214836525573161e = 65536ct = 109733767844983290765119503489592855170752849288516002088462366789671645002019127220142982310787191296062721220321128553167026956288213764125394547996572709867807285688611358568443800185355352482287419029004226687301106507157859735263440122827975982957716941358479236936850859685064250996530125453414484062042Initial AnalysisFrom the use of N and e, we can assume that the cryptosystem used is RSA.The value of $e$ is $65536$, an even number. Another thing to notice is that $N$, which should have been composite, is actually a prime number.At this point, my subconscious mind had already crafted the following solution\\[\\because N \\in\\mathbb{P}\\]\\[\\phi(N) = N - 1\\]\\[d = e^{-1} \\mod \\phi(N)\\]\\[pt = ct^{d} \\mod N\\]After implementing the above in Python and failing to recover the flag, I realized that $e$ and $N - 1$ are both even numbers, and it is not a property of an even number to be coprime to another even number because they share a common factor of $2$.This implies that $\\gcd(e, \\phi(N)) \\neq 1$, which means that the usual $pt = ct^d \\mod N$ formula of RSA for decryption will not work.What will work instead is taking the square root modulo $N$.SolutionAt first glance, the solution might seem fairly simple; take $63556_{th}$ root of the ciphertext — which you’ll find to be computationally infeasible.Another thing we can try is taking consecutive square roots modulo $N$ until we find the correct $65536_{th}$ root, which will be our plaintext. But mind you, this is not regular arithmetic we’re dealing with, taking square root is not the same as taking square root modulo an integer $N$, which we refer to as modular square root in modular arithmetic.But what does it mean to take the square root modulo an integer $N$? To compute an integer $y$ such that\\[y^2 \\equiv x \\mod N\\]If we take $x = 3$ and $N = 13$, the modular square root will be $y = 4$\\[4^2 \\equiv 3 \\mod 13\\]\\[3 \\equiv 16 \\mod 13\\]The method described above involves trying different values of $y$ until the correct solution is found, which can be computationally infeasible when working with large integers, and that’s when the Tonelli-Shanks algorithm comes into play.Tonelli-ShanksThe Tonelli-Shanks algorithm is a method for finding the modular square root of an integer $x$ modulo a prime $p$. In other words, it is a method for finding an integer $y$ such that\\[y^2 \\equiv x \\mod p\\]I will not go into the specifics of the Tonelli-Shanks algorithm, as it is a complex topic on its own. However, it is worth noting that the algorithm has a time complexity of $O(\\log(p)^2)$.All Hail Sage!SageMath has a built-in square_root() function that uses Tonelli-Shanks to find the modular square root. We can just recurse through consecutive square roots modulo $N$ until we find one that contains the flag.from Crypto.Util.number import *def find_roots(exponent, value): if exponent &amp;lt;= 1: if b&quot;flag&quot; in long_to_bytes(int(value)): return long_to_bytes(int(value)) return None if value ^ ((N - 1) // 2) != 1: return sqrt1 = value.square_root() sqrt2 = -sqrt1 result = find_roots(exponent // 2, sqrt1) if result: return result return find_roots(exponent // 2, sqrt2)N = 139799611644152653629701760688199671817845996420960212837951252403071310661876297820375820252422246921626014752203411034874959269400969108775865662803612855844497453022528516710849383838452964627284555992534657432806346951988469594342508507343895146379695281224818693776589341387464488798959628214836525573161e = 65536ct = 109733767844983290765119503489592855170752849288516002088462366789671645002019127220142982310787191296062721220321128553167026956288213764125394547996572709867807285688611358568443800185355352482287419029004226687301106507157859735263440122827975982957716941358479236936850859685064250996530125453414484062042print(find_roots(e, GF(N)(ct)))When we run the code, it prints out the flag: flag{7h3_3xp0n3n7_5h0uld_b3_odd}Wadding — Islamabad QualifierThis was another hard challenge worth 200 points. The following source code was provided.Source Code#!/usr/bin/env python3from binascii import hexlify as h, unhexlify as ufrom Crypto.Cipher import AESfrom flag import FLAGfrom os import urandomimport randomfrom sys import exitimport mathBLOCK_SIZE = AES.block_sizeKEY = urandom(BLOCK_SIZE)SECRET_LENGTH = 64MAX_TRIES = 5000def pad(t): nb = math.ceil(len(t) / BLOCK_SIZE) val = nb * BLOCK_SIZE - len(t) return t + bytes([val] * val)def unpad(t): l = len(t) - t[-1] res = b&quot;&quot; for i in range(l): res += bytes([t[i]]) return resdef aes_encrypt(key, pt): return AES.new(key, AES.MODE_ECB).encrypt(pad(pt))def aes_decrypt(key, ct): return unpad(AES.new(key, AES.MODE_ECB).decrypt(ct))def generate_secret(length): return bytes(random.randint(ord(&#39;0&#39;), ord(&#39;?&#39;)) for _ in range(length))SECRET = generate_secret(SECRET_LENGTH)ENCRYPTED_SECRET = aes_encrypt(KEY, SECRET)def encrypt(): pt = u(input(&quot;Plaintext (in hex): &quot;)) key = u(input(&quot;Key (in hex): &quot;)) ct = aes_encrypt(key, pt) print(f&quot;Ciphertext (in hex): {h(ct).decode()}&quot;)def decrypt(): ct = u(input(&quot;Ciphertext (in hex): &quot;)) key = u(input(&quot;Key (in hex): &quot;)) pt = aes_decrypt(key, ct) print(f&quot;Plaintext (in hex): {h(pt).decode()}&quot;)def get_flag(): print(f&quot;Encrypted secret (in hex): {h(ENCRYPTED_SECRET).decode()}&quot;) secret = u(input(&quot;Secret (in hex): &quot;)) if secret == aes_decrypt(KEY, ENCRYPTED_SECRET): print(f&quot;Flag: {FLAG}&quot;) exit() else: print(&quot;Wrong answer!&quot;)if __name__ == &#39;__main__&#39;: funcs = [exit, encrypt, decrypt, get_flag] tries = 0 print(f&quot;Leak: {SECRET[SECRET_LENGTH-1]}&quot;) while tries &amp;lt; MAX_TRIES: choice = None print(&quot;1. Encrypt&quot;) print(&quot;2. Decrypt&quot;) print(&quot;3. Get flag&quot;) print(&quot;0. Exit&quot;) while choice not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;0&#39;]: choice = input(&quot;&amp;gt; &quot;) funcs[int(choice)]() tries += 1Initial AnalysisThe code presents us with four options: Encryption with AES in ECB mode. Decryption with AES in ECB mode. Get Flag — try to recover the flag by providing the correct value of SECRET Exit the program.A leak of the last character of SECRET is provided, and we have up to 5000 tries to guess its remaining characters. If our input matches the value stored on the server, the flag will be printed.The code implements its own functions for pad and un-pad, which seems a bit weird since Python already has those built-in with its Crypto library. Before we jump into analyzing the these functions, let’s consult ChatGPT to understand padding. In the field of cryptography, it is often necessary to encrypt messages or other data using a specific block size. For example, a block cipher might require that the message be a multiple of 16 bytes in length. If the message is not a multiple of the block size, it must be padded to fit. The PKCS#7 padding scheme is a way to pad a message so that it is the correct size for a block cipher. It works by adding a certain number of padding bytes to the end of the message, where the value of each padding byte is equal to the number of padding bytes added. For example, if a message needs to be padded with 3 bytes to fit a block size of 16, the PKCS#7 padding would be the bytes 0x03 0x03 0x03. To remove the padding, the recipient of the message simply checks the value of the last byte and removes that many padding bytes from the end of the message. For example, if the last byte of the message is 0x03, the recipient would remove the last three bytes of the message (0x03 0x03 0x03) to obtain the original unpadded message. — ChatGPT For example, if the last byte of the message is 0x03, the recipient would remove the last three bytes of the message (0x03 0x03 0x03) to obtain the original unpadded message.Hmm. What if the message’s length is 32 and the last byte of the message is 31?In that case, the un-pad function would return only the first byte of the message, removing the last 31 bytes of the message when, in fact, 31 is not even a correct padding. The correct paddings are 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF. It looks like the un-pad function is missing a crucial check. It just removes the last x bytes without even verifying that padding was actually performed in the first place.SolutionRemember that we were presented with a leak of the last byte? We can use it to our advantage. We’ll need to run the program multiple times till the last byte is 63 which would mean that the program would un-pad 63 bytes from the 64 byte ciphertext, leaving us with just 1 byte to guess. This leaves us with a probability of $\\frac{1}{256}$, which is very achievable.I wrote the following implementation in Python.from pwn import *while True: io = process(&#39;./chall.py&#39;) io.recvuntil(b&quot;Leak: &quot;) leak = int(io.recvline().decode()) if leak == 63: # leaves us with 1/256 possibilities io.recvuntil(b&#39;&amp;gt;&#39;) io.sendline(b&quot;3&quot;) io.recvline() io.recv() io.sendline((hex(54)[2:]).encode()) # taking our guess as 54 (36 in hex) response = io.recvline() if b&quot;Wrong&quot; not in response: print(response) break io.kill() else: io.kill()When we run the code, the flag is printed in $&amp;lt; 2$ minutes.┌──(w㉿kali)-[~]└─$ python3 solve.pyb&#39;Flag: flag{essence_precedes_existence}\\n&#39; Note: I did not have the original flag, so I hardcoded my own for demonstration.Rookie — Final RoundRookie was a hard challenge in final round and was worth 200 points. The following source code was provided.Source Code#!/usr/bin/env python3from binascii import hexlify as h, unhexlify as ufrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom flag import FLAGfrom os import urandomfrom random import seed, randintfrom sys import exitBLOCK_SIZE = AES.block_sizedef aes_encrypt(key, pt): return AES.new(key, AES.MODE_ECB).encrypt(pad(pt, BLOCK_SIZE))def aes_decrypt(key, ct): return unpad(AES.new(key, AES.MODE_ECB).decrypt(ct), BLOCK_SIZE)def random_byte(a=urandom(16)): seed(a) return randint(0, 255)def encrypt_secret(secret): return aes_encrypt(bytes(random_byte() for _ in range(BLOCK_SIZE)), secret)SECRET = urandom(64)ENCRYPTED_SECRET = encrypt_secret(SECRET)def encrypt(): pt = u(input(&quot;Plaintext (in hex): &quot;)) key = u(input(&quot;Key (in hex): &quot;)) ct = aes_encrypt(key, pt) print(f&quot;Ciphertext (in hex): {h(ct).decode()}&quot;)def decrypt(): ct = u(input(&quot;Ciphertext (in hex): &quot;)) key = u(input(&quot;Key (in hex): &quot;)) pt = aes_decrypt(key, ct) print(f&quot;Plaintext (in hex): {h(pt).decode()}&quot;)def get_flag(): print(f&quot;Encrypted secret (in hex): {h(ENCRYPTED_SECRET).decode()}&quot;) secret = u(input(&quot;Secret (in hex): &quot;)) if secret == SECRET: print(f&quot;Flag: {FLAG}&quot;) exit() else: print(&quot;Wrong answer!&quot;)if __name__ == &#39;__main__&#39;: funcs = [exit, encrypt, decrypt, get_flag] while True: choice = None print(&quot;1. Encrypt&quot;) print(&quot;2. Decrypt&quot;) print(&quot;3. Get flag&quot;) print(&quot;0. Exit&quot;) while choice not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;0&#39;]: choice = input(&quot;&amp;gt; &quot;) funcs[int(choice)]()Initial AnalysisThis challenge is very similar to Wadding from Islamabad qualifier with just two differences: The author patched the vulnerability in un-pad function and instead resorted to use the implementation that came built-in with the Crypto library. A new function is added called random_byte.Let’s begin with analyzing random_byte. The function accepts a random byte string of length 16. It then initializes a seed which takes input the random byte string setting a starting point for the random() function, which ensures that the random function generates the same sequence of random integers each time it’s starting point is the same.The encrypt_secret function calls the random_byte function 16 times for generating a random key. At first glance, this fooled me to think that a random byte will be generated every 16 times the function is called. Instead, what actually happens is each time the function is called, a same random byte is generated.&amp;gt;&amp;gt;&amp;gt; def random_byte(a=urandom(16)):... seed(a)... return randint(0, 255)...&amp;gt;&amp;gt;&amp;gt; [random_byte() for _ in range(16)][126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126]This suggests that this function’s capability is limited to generating a combination of total 256 possible keys:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2].........[253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253][254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254][255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]SolutionThe idea is to brute-force the key from a total of 256 keys. However, we can not just send the keys to the server for decryption, because if the key is incorrect, the server will crash, and we’ll have to start again. A better way to solve this challenge would be to create a list of all possible keys, loop through them to find the correct key, then decrypt the secret and send it to the server. If our secret matches the one stored on the server, we’ll get the flag.I wrote the following implementation in Python.from pwn import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpaddef generate_all_keys(): keys = [] for i in range(256): keys.append(bytes([i]) * 16) return keysdef aes_decrypt(key, ct): return unpad(AES.new(key, AES.MODE_ECB).decrypt(ct), 16)possible_keys = generate_all_keys()io = process(&#39;./chall.py&#39;)io.recvuntil(b&#39;&amp;gt;&#39;)io.sendline(b&quot;3&quot;)ct = bytes.fromhex(io.recvline().decode().split(&quot;: &quot;)[-1].strip())io.recv()for key in possible_keys: try: secret = aes_decrypt(key, ct) io.sendline(secret.hex().encode()) print(io.recvline()) break except: passRunning this program a few times, we’ll get the flag. (worked for me in $\\leq 5$ tries)┌──(w㉿kali)-[~]└─$ python3 solve.pyb&#39;Flag: flag{or_existence_precedes_essence?}\\n&#39; Note: I did not have the original flag, so I hardcoded my own for demonstration.Abstract — Final RoundAbstract was a hard challenge worth 200 points. The following source code was provided.Source Codefrom Crypto.Util.number import getPrime, inverse, bytes_to_longimport randomimport mathFLAG = b&#39;flag{????????????????????}&#39;def gen_key(): q = getPrime(512) upper_bound = int(math.sqrt(q // 2)) lower_bound = int(math.sqrt(q // 4)) f = random.randint(2, upper_bound) while True: g = random.randint(lower_bound, upper_bound) if math.gcd(f, g) == 1: break h = (inverse(f, q)*g) % q return (q, h), (f, g)def encrypt(q, h, m): assert m &amp;lt; int(math.sqrt(q // 2)) r = random.randint(2, int(math.sqrt(q // 2))) e = (r*h + m) % q return edef decrypt(q, h, f, g, e): a = (f*e) % q m = (a*inverse(f, g)) % g return mpublic, private = gen_key()q, h = publicf, g = privatem = bytes_to_long(FLAG)e = encrypt(q, h, m)print(f&#39;Public key: {(q,h)}&#39;)print(f&#39;Encrypted Flag: {e}&#39;)A tale of stolen challengesI will not do a write-up for this challenge, since this was a stolen challenge from CryptoHack’s Find the Lattice. You may verify this by pasting the provided source code on google, the first returned result is the original source of this challenge. I spent around 2 hours during the competition trying to do the math for this challenge, and failed miserably. Meanwhile, almost every other team solved it by pasting the code on google and finding the solutions.There’s you putting in an effort and time, trying to solve a challenge on your own, and then there are those who know that the solution is available on the internet. Is this not a waste of effort?Feedbacks were shared with the organizers right after the online qualifying round (which also consisted of a stolen challenge from Fword CTF), and yet they still did nothing to address the participants’ concerns. This is just one example. There were stolen and repeated challenges throughout the hackathon from the online qualifying round to the city qualifier rounds to the final round. I find it hard to understand how such sloppiness at a national level competition could go unnoticed.Feedback for OrganizersFor future CTF competitions, it’s important for the organizers to do their homework and really understand what goes into creating a CTF. It takes a lot of research, planning, and creativity to come up with fresh ideas for challenges. It’s also important to check and double check that your challenges are actually solvable, making sure the platform is available throughout the whole competition, providing official write-ups after the CTF ends, and that you have a plan for when things go wrong (cheating/flag sharing). Organizers should consider reading this CTF guideline to ensure that the competition runs smoothly and provides a meaningful and enjoyable experience for all participants.Ending noteTo wrap things up, cryptography can be a lot of fun to work with, especially when you’re solving challenges like in a CTF. But it’s important to remember that real-world situations are a lot different, and it’s essential to use established, tried-and-true algorithms and libraries to keep your systems secure. I hope that the writeup has provided some insight into the process of dos and don’ts of cryptography and that you feel motivated to try your hand at some CTFs of your own. I’m happy to answer any questions you might have about the techniques discussed in this writeup, so feel free to reach out to me on twitter or discord (wonderchild#3321).That’s All Folks, Happy Hacking!" }, { "title": "Pakistan Cyber Security Challenge CTF - Cryptography Write-Up", "url": "/posts/PCC-Crypto/", "categories": "PCC, Crypto", "tags": "CTF, crypto, PCC", "date": "2022-08-04 17:30:00 +0500", "snippet": "Hello folks, recently I participated in the 1st Pakistan Cyber Security Challenge CTF. My team secured 1st position in the qualifying round and came in 2nd place in the final round held at Air University, Islamabad. It was a wonderful experience, the challenges were well-designed, and Team AirOverflow is to be commended for their efforts.All of the cryptography challenges from the qualifier and final rounds will be discussed in detail in this write-up.Qualifier RoundBaquette The french make excellent cuisine. Well, even stronger encryption schemes. Do you really think you can fully eat this baquette?Key: auctfTbkl ns hqm doot hwdcptwy wkimel, kl nt?Bkgy: Buux.A2VmdVG3ZQzlNHxnuLwmKAqvxUUmcgWzh21hwpJlbRmzEnDrSB5kFiiGVOPNWnnkRCF1TZK0EXHhRCJfZ3Kmc3L5Z3wtZQ5hRrFtBPWfx2n0tK9ixZK0EXD9The inclusion of the French in the challenge description suggests that this is the well-known Vigenere Cipher, since it was created in France. The key has been provided, so let’s open CyberChef and enter the ciphertext and key.The plaintext yields another ciphertext which appears to be base64 encoded, we can decode it using CyberChef.And we got the flag!Flag: AUCTF{baquettes_are_tasty_when_based_with_butter}Climber Have you ever seen someone who is 7 feet tall, fencing on a 5-10 feet long railing? Well, me neither.t1_cfudrnu{0_ooathb_ths3z}1__zseThe Rail Fence Cipher is referenced in the challenge description, with 7 being the key and offset between 5 and 10. So let’s test all five key-offset pairs on CyberChef. On 7 as key 9 as offset we obtain the correct plaintext.Flag: auctf{th1s_sh0u1d_b3_ezz_or_not}RSACiphern = 31436211274852062801590948458671058204728701377920047195870016302697956796267506278727106968536534553505650010973423533569252216811398069950057574348601027314737123 e = 65537 c = 22840372395669361935504971154513566142872479734989306848229554805124371541157041389213350875178287707977731738003789623205786790284199917036685723196756139847839346SolutionThis is an RSA challenge, as the name implies. We are given the ciphertext ct as well as the public key (n, e), where n is a product of two unknown primes p and q and e is the public exponent.According to Wikipedia, the difficulty of dividing the modulus n into its prime parts p and q determines the security of RSA and as of 2020, the largest publicly known broken RSA key is RSA-250, which has 829 bits.Meanwhile, the supplied n value is just 544 bits long and hence easily factorable. Let’s write a python script that factors n to p and q.Now that we have the values of p and q, the rest of the solution is basically textbook RSA, in which we compute the value of phi and then its private exponent d by:\\[phi = (p-1) \\times (q - 1)\\]\\[d = e^{-1}\\ mod\\ phi\\]Finally, decrypt the ciphertext by computing\\[plaintext = c^d\\ mod\\ n\\]Codefrom Crypto.Util.number import *from sympy.ntheory import factorintn = 31436211274852062801590948458671058204728701377920047195870016302697956796267506278727106968536534553505650010973423533569252216811398069950057574348601027314737123e = 65537c = 22840372395669361935504971154513566142872479734989306848229554805124371541157041389213350875178287707977731738003789623205786790284199917036685723196756139847839346p, q = factorint(n)phi = (p - 1) * (q - 1)d = inverse(e, phi)pt = pow(c, d, n)print(long_to_bytes(pt))Flag: auctf{l4st_FLAG}KinIn this challenge, we are given an encryption function and a list of the decimal equivalents of the encrypted flag’s bytes.import randomflag = REDACTEDdef encrypt(data): mod = 256 a = 203 b = random.randint(1,mod) res = [] for i in data: enc = (a*ord(i) + b) % mod res.append(enc) return resprint(encrypt(flag))# flag = [152, 116, 46, 169, 143, 54, 152, 143, 143, 136, 231, 196, 2, 136, 222, 2, 99, 19, 30, 152, 134, 152, 99, 81, 196, 204]It appears that the encryption function is akin to that of the Affine Cipher, hence the name Kin.The encryption function for a single letter x in mathematical notation is\\[E(x)=(ax+b)\\ mod\\ m\\]where a and b are the keys, and m is the number of letters in the character set, which in ASCII is 256. The values for a and m are known, but the value of b is picked at random from a range of 1...256, which we can easily brute-force.The decryption function for a single letter x is\\[D(x) = a^{-1}(x-b)\\ mod\\ m\\]where $a^{-1}$ is the modular multiplicative inverse of a modulo m. We can find its value using invert function from the gmpy2 library.Let’s now write the decryption function and recover the plaintext.def decryption(msg): for b in range(256): # brute-forcing the value for b pt = &quot;&quot; for char in msg: char = 227 * (char - b) % 256 pt += chr(char) if &quot;auctf&quot; in pt: print(pt) breakFlag: auctf{aff1ne_1s_br3akable}AssociativeWhat matters is if A==B then B==A.CIPHER_TEXT = ExQNEAkWEwoLOV5HPBUVK3QQDEIRXwQEEw== KEY = cmFuZG9ta2V5Zm9yY3RmWERzZXZlbg==SolutionThe use of the word Associative and the suggestion of a one-to-one relation between A and B indicate that plaintext is subjected to a straightforward XOR operation. Because XOR is associative, if $a \\oplus b = c$, then $b \\oplus c = a$, and similarly $a \\oplus c = b$.Both the ciphertext and the key were encoded using base64, therefore we must first decode them to their original byte form before recovering the plaintext by conducting a bitwise XOR operation on the ciphertext and key.from pwn import *import base64CIPHER_TEXT = &quot;ExQNEAkWEwoLOV5HPBUVK3QQDEIRXwQEEw==&quot;KEY = &quot;cmFuZG9ta2V5Zm9yY3RmWERzZXZlbg==&quot;cipher_text = base64.b64decode(CIPHER_TEXT)key = base64.b64decode(KEY)print(xor(cipher_text, key))Flag: auctf{xor_15_ass0ci4t1ve}Final RoundWrite34flag = flag.encode()for i in range(3): flag = base64.b16encode(flag) flag = base64.b32encode(flag) flag = base64.b64encode(flag)fernet = Fernet(key)for i in range(3): flag = fernet.encrypt(flag)for i in range(3): flag = binascii.hexlify(flag)Attachments:key.txtcode.txtcipher.txtFor this challenge, we’re provided with a custom encryption algorithm that first encodes the flag three times using base16, base32, and base64. The algorithm then utilizes fernet to encrypt the flag three times, and finally, and the flag is then converted to hex three times.The solution is fairly simple, all that needs to be done to recover the plaintext is to reverse the algorithm since we already know the key and the ciphertext.from binascii import unhexlifyfrom cryptography.fernet import Fernetimport base64flag = open(&quot;flag.txt&quot;).read()key = &quot;YntAd4Y6MNT0uRgfsHnagRPXux7Hgs0lwIjKbrd8MbQ=&quot;fernet = Fernet(key)for i in range(3): flag = unhexlify(flag)for i in range(3): flag = fernet.decrypt(flag)for i in range(3): flag = base64.b64decode(flag) flag = base64.b32decode(flag) flag = base64.b16decode(flag)print(flag)Flag: AUCTF{suCh_3nc0d1ng_muCh_fl4g_w0w}BiggiE small :D Last time our RSA encryption was weak, a mathematician suggested to increase the exponent, because more bits makes it more secure.n: 609983533322177402468580314139090006939877955334245068261469677806169434040069069770928535701086364941983428090933795745853896746458472620457491993499511798536747668197186857850887990812746855062415626715645223089415186093589721763366994454776521466115355580659841153428179997121984448771910872629371808169183e: 387825392787200906676631198961098070912332865442137539919413714790310139653713077586557654409565459752133439009280843965856789151962860193830258244424149230046832475959852771134503754778007132465468717789936602755336332984790622132641288576440161244396963980583318569320681953570111708877198371377792396775817Attachments:flag.encIt is an RSA challenge, and the description suggests that a big public exponent is used. Looking at the public key, it can be seen that the value of e is too big, which is unusual. A quick google search reveals that having an unusually big value for the public exponent results in a small value for the private exponent d, which makes RSA prone to Weiner’s Attack. Read in detail from Twenty Years of Attacks on the RSA Cryptosystem.from Crypto.Util.number import *def wiener(e, n): # Convert e/n into a continued fraction cf = continued_fraction(e/n) convergents = cf.convergents() for kd in convergents: k = kd.numerator() d = kd.denominator() # Check if k and d meet the requirements if k == 0 or d%2 == 0 or e*d % k != 1: continue phi = (e*d - 1)/k # Create the polynomial x = PolynomialRing(RationalField(), &#39;x&#39;).gen() f = x^2 - (n-phi+1)*x + n roots = f.roots() # Check if polynomial as two roots if len(roots) != 2: continue # Check if roots of the polynomial are p and q p,q = int(roots[0][0]), int(roots[1][0]) if p*q == n: return d return None# Test to see if our attack worksif __name__ == &#39;__main__&#39;: n = 609983533322177402468580314139090006939877955334245068261469677806169434040069069770928535701086364941983428090933795745853896746458472620457491993499511798536747668197186857850887990812746855062415626715645223089415186093589721763366994454776521466115355580659841153428179997121984448771910872629371808169183 e = 387825392787200906676631198961098070912332865442137539919413714790310139653713077586557654409565459752133439009280843965856789151962860193830258244424149230046832475959852771134503754778007132465468717789936602755336332984790622132641288576440161244396963980583318569320681953570111708877198371377792396775817 d = wiener(e,n) c_bytes = open(&quot;flag.enc&quot;, &quot;rb&quot;).read() c = bytes_to_long(c_bytes) pt = pow(c, d, n) print(long_to_bytes(int(pt)))Flag: auctf{huge_e_small_d_and_wiener_attack}We can mark the challenge as solved here. However, there’s another, unintended way to solve this challenge. The modulus used by the challenge author is quite old, and can easily be factorized into p and q using factordb.com.Rest is textbook RSA, we can simply follow the same steps as we did in the RSA challenge from the qualifier round. However, the flag.enc consists of bytes rather than long integer this time, so we will use the bytes_to_long function of pycryptodome library to convert the ciphertext to a long integer.from Crypto.Util.number import *n = 609983533322177402468580314139090006939877955334245068261469677806169434040069069770928535701086364941983428090933795745853896746458472620457491993499511798536747668197186857850887990812746855062415626715645223089415186093589721763366994454776521466115355580659841153428179997121984448771910872629371808169183e = 387825392787200906676631198961098070912332865442137539919413714790310139653713077586557654409565459752133439009280843965856789151962860193830258244424149230046832475959852771134503754778007132465468717789936602755336332984790622132641288576440161244396963980583318569320681953570111708877198371377792396775817flag = open(&quot;flag.enc&quot;, &quot;rb&quot;).read()ct = bytes_to_long(flag)# from factordbp = 22107961593273663554447672179167919592270857343971618325649212520279122827566022270428817505638791153667398184068987608971763363269212331920067006335889541q = 27591125068163886831989228774178759832120484388897183929367433612315983402979538404952530012269465045393978140179601040530392691765067542341015115680614163phi = (p - 1) * (q - 1)d = inverse(e, phi)pt = pow(ct, d, n)print(long_to_bytes(pt))Flag: auctf{huge_e_small_d_and_wiener_attack}555import randomfrom Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padbits = 128shares = 30## pardon my bad coding practices## improvise adapt dryrundef encrypt(flag): key = random.randbytes(16) cipher = AES.new(key, AES.MODE_ECB) enc_flag = cipher.encrypt(pad(flag, 16)) f = open(&quot;flag4.enc&quot;, &quot;w&quot;) return enc_flag.hex()poly = [random.getrandbits(bits) for _ in range(shares)]flag = open(&quot;./flag4.txt&quot;, &quot;rb&quot;).read()random.seed(poly[0])print(encrypt(flag))x = int(input(&quot;input x: &quot;))print(sum(map(lambda i: poly[i] * pow(x, i), range(len(poly)))))We are provided with a Python code that generates a random array of size 30, then uses the first element as a seed to the random function. The encryption function is then called, which produces a random key and encrypts the flag with AES.I was unable to solve this challenge during the event, since the challenge required some time to tinker with it, and an understanding of positional number system. And I lacked both 🤡.The encryption function is straightforward. AES with ECB mode is used, and a random key of 16 bytes is created. Line 22 shows the usage of a seed poly[0], which is also generated randomly.The usage of seed ensures that the random function generates the same random integers each time it is run. Once we retrieve the seed’s value, solving this challenge will be a piece of cake.The program takes input the value of x on line 25 and then, on line 26, loops over the elements of the list poly and sums the product of values on each index of poly array with $x^i$ where i is the iterator.The last line of code can also be expressed as:\\[\\sum_{i=0}^{29} poly_{i} \\times x^i\\]Or in python:s = 0for i in range(len(poly)): s += poly[i] * pow(x, i)print(s)We need to extract poly[0] from the sum. We know that any base to the power 0 is 1 e.g.: \\(2^0 = 1\\) , and similarly \\(0^0 = 1\\) .If we enter x as 0, we can trick the program into doing\\[\\sum_{i=0}^{29} poly_{i} \\times 0^i\\]For all iterations except \\(i=0\\), the result of the product will be 0. In case of \\(i = 0\\), the right hand side of the product will become 1 and the product will be equal to poly[i]. This will only be true because\\[poly_0 \\times 0^0 = poly_0 \\times 1 = poly_0\\]Hence, the sum will be equal to poly[0]. Now we can simply use it as a seed to generate our key and decrypt the flag.from Crypto.Cipher import AESimport randomenc_flag = &quot;f79beca540b155be28b83c8b871640888766c70b82670f2cde28c40976d46fc7&quot;flag_bytes = bytes.fromhex(enc_flag)seed = 270882600965622237109048171195266900279 # poly[0] or the sum when x is 0random.seed(seed)key = random.randbytes(16)cipher = AES.new(key, AES.MODE_ECB)dec_flag = cipher.decrypt(flag_bytes)print(dec_flag)Flag: auctf{hash3lizer_ust@@d_&amp;lt;3}Mathematics, Cryptography, Magic, Mystery, Beauty. That’s all Folks. Have a great day!" }, { "title": "Doe, a deer — DeconstruCT.F 2021", "url": "/posts/DeconstruCT.F-Doe-A-Deer/", "categories": "crypto", "tags": "crypto", "date": "2021-10-02 16:20:00 +0500", "snippet": "Last week, my team and I took part in DeconstruCT.F, a 24-hour Capture The Flag event organized by the Google Developers Student Club at Vellore Institute of Technology. It was an exciting competition, and after 24 hours of no sleep, we emerged as winners. Among the challenges I solved in different categories including Cryptography, Web, Forensics, the one that really intrigued me and motivated me to write about was a Cryptography challenge called “Doe, A Deer”. The challenge was worth 500 points, involved studying about music theory, then manually deciphering a music sheet cipher, and at the end of the competition, only three teams managed to solve it. So, with out further ado, let’s get started.Challenge DescriptionMark, a very gifted musician, is suddenly missing after his music class. He is said to have been upset after turning in his assignment. He had worked very hard on it, it was his first original. Here, you can see his work. I’m sure you can find him, he wouldn’t have gone far.Files Attached Doe a deer.pdf tune_700.mp3SolutionLets begin by analyzing the files we’ve been given. A quick look at the pdf file reveals that it is a Music Sheet Cipher.Let’s see whether there’s a deciphering tool available online. A quick google search for Music Sheet cipher decoding tool takes us to dcode.fr. I tried decoding it, but the tool gave me gibberish.If that’s not going to work, then let’s get back to our old pal Google and search for Music Sheet Ciphers. The second search from the top leads to this website, which is a Solfa Cipher online encoding tool. Let’s try encoding something and check whether the result matches the ciphertext we’ve been given.Hmm. It does in a way. Let’s play about with it a little and see if we can come up with a ciphertext that’s similar to the pdf one. I couldn’t do it. However, we’re certain it’s Solfa Cipher now. Let’s find an online decoder and get the flag. Child’s play right? But guess what?There’s no online decoding tool for it. We will have to decipher it manually.Back to google, I found this writeup from 2017 which states: Each note is linked to the seven pitches of the solfege, i.e. Do (D), Re (R), Mi (M), Fa (F), Sol (S), La (L) and Si(T).The columns represent the pitch, while the rows represent the time units for each note (1, 2, 3 or 4). It’s mentioned in the writeup that the key is defined using a clef, a tonic, a mode and a rythmic unit.These 4 elements when combined, generate a key which can be used for both encryption and decryption. We know that the first line of the pdf is the key used for encryption which means we can figure out the settings of the 4 elements. I tried multiple settings on this website to see if I could get the same key as we have. Luckily, with Treble as the Clef, C as the tonic, Major as the Mode, and Eight as the rythmic unit I was able to get the original key back.The given key specifies a 1/8 rhythm, as such an Eighth note will be worth 1-time unit, a Quarter note will be worth 2-time units and the half note will be worth 4-time units.After studying a little bit of music theory I was able to figure out that a . with a music note meant n+1 time units. At this point, I had a good understanding of how the Solfa Cipher worked, but I wasn’t sure what the z-like looking note signified, so I asked the admin about it, and he answered that it’s a buffer character worth a 2-time unit.Using the Key, we can write out the correct scale with its associated solfege syllables (Do, Re, Mi, Fa, So, La, Ti) and divide up the rhythms into counts of four 8th notes. The first downbeat is always 1.Let’s start mapping the counts onto the pdf. I have tried to explain the mapping process in the following diagram.We’re done with the hard part, now we just need to know the alphabet equivalents of all solfege syllables. We can easily find the solfege syllables’ alphabets equivalent on google.We have got all we need to decrypt the ciphertext. Let’s begin the process.After applying the above process on all of the ciphertext, you’ll end up with:R,1 M,1 F,3 F,1 T,1 D,3 D,3 R,4 F,3 T,1 F,3 R,1 M,3 M,1 T,4 S,1 M,4 T,1 D,1 D,1 T,1 M,4 T,1 L,3 R,1 T,4 S,1 F,3 R,4 F,3 T,3 F,1 R,1 R,3Using the table in Figure 1, we decode it to following plaintext:iamsorrymomihavegottogolivemymusicWe have the plaintext but no idea what to do with it. Let’s have a look at the tune_700.mp3 file. Running strings command on it yields a Google Drive link that yields another pdf.It’s a password-protected PDF document. Perhaps the plaintext we obtained is the pdf’s passcode?Let us give it a go.And, voila! We have got the flag." } ]
